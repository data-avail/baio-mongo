// Generated by CoffeeScript 1.3.3
(function() {
  var Db, MongoDb, async, conn, mongodb, _;

  mongodb = require("mongodb");

  async = require("async");

  Db = mongodb.Db;

  conn = require("./connection");

  _ = require("underscore");

  MongoDb = (function() {

    function MongoDb(config) {
      var Server;
      this.config = config;
      if (typeof this.config === "string") {
        this.config = conn.str2config(this.config);
      }
      Server = mongodb.Server;
      this.db = new Db(this.config.database, new Server(this.config.host, this.config.port), {
        w: 1
      });
      this.collection = null;
    }

    MongoDb.prototype.open = function(table, onDone) {
      var _this = this;
      return this.openCollection(table, function(err, coll) {
        _this.collection = coll;
        if (onDone) {
          return onDone(err, coll);
        }
      });
    };

    MongoDb.prototype.openCollection = function(table, onDone) {
      var _this = this;
      return async.waterfall([
        function(ck) {
          return _this.db.open(ck);
        }, function(d, ck) {
          if (_this.config.user) {
            return d.authenticate(_this.config.user, _this.config.pass, ck);
          } else {
            return ck(null, null);
          }
        }, function(f, ck) {
          if (table) {
            return _this.iniCollection(table, ck);
          } else {
            return ck();
          }
        }
      ], function(err, coll) {
        if (onDone) {
          return onDone(err, coll);
        }
      });
    };

    MongoDb.prototype.iniCollection = function(table, onDone) {
      var _this = this;
      return this.db.collection(table, function(err, collection) {
        if (onDone) {
          return onDone(err, collection);
        }
      });
    };

    MongoDb.prototype.close = function() {
      return this.db.close();
    };

    MongoDb.prototype._iniCollection = function(table, onDone) {
      var _this = this;
      return this.db.collection(table, function(err, collection) {
        if (!err) {
          _this.collection = collection;
        }
        if (onDone) {
          return onDone(err, collection);
        }
      });
    };

    MongoDb.GetById = function(config, table, id, onDone) {
      return MongoDb.GetSingle(config, table, {
        id: id
      }, onDone);
    };

    MongoDb.GetSingle = function(config, table, filter, onDone) {
      return MongoDb.SelectSingle(config, table, filter, {}, onDone);
    };

    MongoDb.SelectSingle = function(config, table, filter, select, onDone) {
      return MongoDb.SelectBatch(config, table, filter, select, function(err, data) {
        if (!err && data) {
          data = data[0];
        }
        return onDone(err, data);
      });
    };

    MongoDb.ReadBatch = function(config, table, filter, onDone) {
      return MongoDb.SelectBatch(config, table, filter, {}, onDone);
    };

    MongoDb.SelectBatch = function(config, table, filter, select, onDone) {
      var db;
      db = new MongoDb(config);
      return async.waterfall([
        function(ck) {
          return db.open(table, ck);
        }, function(coll, ck) {
          return db.readBatch(filter, select, ck);
        }
      ], function(err, items) {
        db.close();
        return onDone(err, items);
      });
    };

    MongoDb.prototype.readBatch = function(filter, select, onDone) {
      if (_.isFunction(select)) {
        onDone = select;
        select = {};
      }
      return this.collection.find(filter, select, function(err, cusror) {
        var res;
        res = [];
        return cusror.each(function(err, item) {
          if (!err && item) {
            return res.push(item);
          } else {
            return onDone(err, res);
          }
        });
      });
    };

    MongoDb.prototype.read = function(filter, onIter, onDone) {
      return this.collection.find(filter, function(err, cusror) {
        return cusror.each(function(err, item) {
          if (item) {
            return onIter(err, item);
          } else {
            return onDone(err);
          }
        });
      });
    };

    MongoDb.prototype.readNext = function(filter, onNext) {
      return this.collection.find(filter, function(err, cusror) {
        if (!err) {
          return cusror.nextObject(onNext);
        } else {
          return onNext(err);
        }
      });
    };

    MongoDb.prototype.find = function(filter, onDone) {
      return this.collection.find(filter, onDone);
    };

    MongoDb.prototype.count = function(filter, onDone) {
      return this.collection.count(filter, onDone);
    };

    MongoDb.prototype.update = function(items, onDone) {
      return MongoDb.Update(this.collection, items, onDone);
    };

    MongoDb.Update = function(coll, items, onDone) {
      var errs;
      errs = [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      return async.forEach(items, function(item, ck) {
        return coll.update({
          _id: item._id
        }, item, {
          safe: true,
          multi: false,
          upsert: true
        }, function(err, docs) {
          if (err) {
            errs.push(err);
          }
          return ck();
        });
      }, function() {
        if (onDone) {
          return onDone((errs.length ? errs : null));
        }
      });
    };

    MongoDb.prototype.insert = function(items, onDone) {
      return MongoDb.Insert(this.collection, items, onDone);
    };

    MongoDb.Insert = function(coll, items, onDone) {
      var errs;
      errs = [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      return async.forEach(items, function(item, ck) {
        return coll.insert(item, {
          safe: true
        }, function(err, docs) {
          if (err) {
            errs.push(err);
          }
          return ck();
        });
      }, function() {
        if (onDone) {
          return onDone((errs.length ? errs : null));
        }
      });
    };

    /*
      coll.insert items, safe : true,  (err, docs) =>
        if err then log.warn code : "data_insert", err : err
        if onDone then onDone err
    */


    MongoDb.prototype.insertIfUpdate = function(items, insert, onDone) {
      return MongoDb.InsertIfUpdate(this.collection, items, insert, onDone);
    };

    MongoDb.InsertIfUpdate = function(coll, items, insert, onDone) {
      var errs;
      errs = [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      return async.forEach(items, function(item, cb) {
        return async.waterfall([
          function(ck) {
            return coll.insert(i, {
              safe: true
            }, function(err) {
              if (err && err.message.indexOf('E11000 ') !== -1) {
                return ck(null, false);
              } else {
                return ck(err, true);
              }
            });
          }, function(isIns, ck) {
            var id;
            if (!isIns) {
              id = item["_id"];
              delete item["_id"];
              return coll.update({
                _id: id
              }, {
                $set: item
              }, {
                multi: false,
                safe: true,
                upsert: false
              }, ck);
            } else {
              return ck();
            }
          }
        ], function(err) {
          if (err) {
            errs.push(err);
          }
          return cb();
        });
      }, function() {
        if (onDone) {
          return onDone((errs.length ? errs : null));
        }
      });
    };

    MongoDb.InsertWithFilter = function(config, table, items, onFilter, onDone) {
      var db;
      db = new MongoDb(config);
      return async.waterfall([
        function(ck) {
          return db.open(table, ck);
        }, function(coll, ck) {
          return db.insertWithFilter(items, onFilter, ck);
        }
      ], function(err, items) {
        db.close();
        return onDone(err, items);
      });
    };

    MongoDb.prototype.insertWithFilter = function(items, onFilter, onDone) {
      var errs,
        _this = this;
      errs = [];
      if (!Array.isArray(items)) {
        items = [items];
      }
      return async.forEach(items, function(item, ck) {
        var fr;
        fr = onFilter(item);
        return _this.collection.count(fr, function(err, count) {
          if (!count) {
            return _this.insert(item, ck);
          } else {
            return ck();
          }
        });
      }, onDone);
    };

    MongoDb.Ins = function(config, table, item, autoMap, callback) {
      var db;
      db = new MongoDb(config);
      return async.waterfall([
        function(ck) {
          return db.open(table, ck);
        }, function(coll, ck) {
          var ins;
          if (autoMap) {
            ins = _.extend({}, item);
            ins._id = item.id;
            delete ins.id;
          }
          return db.insert(ins, ck);
        }
      ], function(err, res) {
        db.close();
        if (!err && autoMap) {
          _.extend(item, res);
          item.id = item._id;
          delete item._id;
        }
        return callback(err, item);
      });
    };

    MongoDb.Upd = function(config, table, filter, item, callback) {
      var db;
      db = new MongoDb(config);
      return async.waterfall([
        function(ck) {
          return db.open(table, ck);
        }, function(coll, ck) {
          return coll.find(filter, {
            _id: 1
          }, ck);
        }, function(cursor, ck) {
          return async.doWhilst(function(item) {
            return item === null;
          }, (function(cb) {
            return cursor.nextObject(function(err, doc) {
              return db.collection.update({
                _id: doc.id
              }, {
                $set: item
              }, {
                multi: false,
                safe: true,
                upsert: false
              }, cb);
            });
          }), ck);
        }
      ], function(err) {
        db.close();
        return callback(err);
      });
    };

    MongoDb.UpdById = function(config, table, id, item, callback) {
      var db;
      db = new MongoDb(config);
      return async.waterfall([
        function(ck) {
          return db.open(table, ck);
        }, function(coll, ck) {
          return db.collection.update({
            _id: id
          }, {
            $set: item
          }, {
            multi: false,
            safe: true,
            upsert: false
          }, ck);
        }
      ], function(err) {
        db.close();
        return callback(err);
      });
    };

    return MongoDb;

  })();

  exports.MongoDb = MongoDb;

}).call(this);
